[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Funathon 2023 - Sujet 2",
    "section": "",
    "text": "Contexte et description du sujet\nA compléter."
  },
  {
    "objectID": "app0.html",
    "href": "app0.html",
    "title": "1  Utilisation de PostgreSQL",
    "section": "",
    "text": "A compléter."
  },
  {
    "objectID": "app1.html",
    "href": "app1.html",
    "title": "2  Exploration des données RPG",
    "section": "",
    "text": "A compléter davantage."
  },
  {
    "objectID": "app2.html",
    "href": "app2.html",
    "title": "3  Cultures et prévisions climatiques",
    "section": "",
    "text": "A compléter."
  },
  {
    "objectID": "physio_era5.html",
    "href": "physio_era5.html",
    "title": "4  Évolution de la date théorique de récolte",
    "section": "",
    "text": "Les organismes, dont les plantes, ont besoin d’une certaine quantité de chaleur pour se développer. La notion de degrés jours a été introduite par les biologistes pour quantifier ce besoin physiologique. Il s’exprime par la somme des différences entre la température moyenne journalière et une température de base1.1 Degré jour de croissance. Wikipedia\n\\[DJ_{n} = \\sum_{j=1}^{n}{\\frac{T_{max, j} - T_{min, j}}{2} - T_{base}}\\]\nLe maïs a une température de base de 6 °C et il lui faut 1500 DJ (variable selon la précocité de la variété) pour être récolté pour l’ensilage2 destiné à nourrir le bétail, ou 1700 DJ pour le maïs grain. Les températures supérieures à 30 °C stoppent le développement végétatif. Le semis se fait début avril3.2 Spotifarm3 Céré’Obs. FranceAgrimer\nPeut-on voir comment a évolué la date de récolte théorique du maïs au cours des 40 dernières années ?\n\n5 Données\n\nLe RPG recense les parcelles déclarées à la PAC par les agricuteurs : données graphiques et leur culture principale.\nLes données sont disponibles dans une base PostGIS.\nERA5 agrometeorological indicators est un jeu de données issu d’un projet de réanalyse météorologique qui vise à uniformiser et corriger les données historiques (ERA5). Il fournit des paramètres agro-météorologiques de surface quotidiens pour la période allant de 1979 à aujourd’hui à une résolution spatiale de 0,1 ° (soit environ 8×11 km en France).\nLes données de température moyenne 1979-2022 (87 Go à l’origine) ont été préchargées sur Minio et limitées à l’emprise de la métropole, représentant au final 16 000 fichiers de 76 ko = 1.1 Go).\nElles sont au format NetCDF. Un package R existe pour importer et requêter ce jeu de données particulier : {ag5Tools}. Les données peuvent aussi être traitées avec les packages de manipulation de rasters tels que {terra} (ou {raster}) et {stars}.\n\n\n\n6 Proposition\nEstimer l’évolution des dates potentielles de récolte du maïs grain (code culture : MIS) dans les différents bassins de productions français depuis 1980.\n\n\n7 Préparation\nIl faut avoir préalablement copié les données depuis le stockage S3 Minio :\n$ mc cp -r s3/projet-funathon/2023/sujet2/era5/ funathon2023_sujet2/donnees/era5/\nPour se connecter à la base PostgreSQL, il faudra avoir défini votre mot de passe comme variable d’environnement en ajoutant PASS_POSTGRESQL=xxxx dans le fichier ~/.Renviron.\n\n\nvoir le code\nlibrary(stars) # manipulation de rasters\nlibrary(terra) # manipulation de rasters\nlibrary(tidyverse) # manipulation des données\nlibrary(glue)      # interpolation de chaine de caractères\nlibrary(fs)        # gestion du système de fichier\nlibrary(gtsummary) # tableaux de modèles stat\nlibrary(RPostgres) # connxion PostgreSQL\nlibrary(sf)        # manipulation de données spatiales vecteur\nlibrary(leaflet)   # carto web\nlibrary(knitr)     # génération du document\n\n# localisation des données dans le stockage \"local\"\nrep_era5 <- \"donnees/era5\"\n\n# pour avoir les noms de dates en français\ninvisible(Sys.setlocale(\"LC_ALL\", \"fr_FR.UTF-8\"))\n\noptions(knitr.kable.NA = \"\")\n\ncnx <- dbConnect(Postgres(),\n                 user = \"projet-funathon\",\n                 password = Sys.getenv(\"PASS_POSTGRESQL\"),\n                 host = \"postgresql-438832\",\n                 dbname = \"defaultdb\",\n                 port = 5432,\n                 check_interrupts = TRUE)\n\n\n\n\n8 Définition des bassins de production du maïs grain\nOn peut, par exemple, extraire les 10 principales zones où la densité de culture est la plus forte. Cela peut se faire par commune ou avec un lissage.\n\n\nvoir le code\n# Lissage\n#\n# michael.delorme - 2021-08-26\n\n# utils -------------------------------------------------------------------\n\n#' rounding\n#' from plyr\n#'\n#' @param x\n#' @param accuracy\n#' @param f\n#'\n#' @return\nround_any <- function(x, accuracy, f = round) {\n  \n  f(x / accuracy) * accuracy\n}\n\n#' Generate a grid of coordinates from a spatial layer\n#'\n#' Memoised to get a faster result when used multiple times on the same extent\n#'\n#' @param zone sf object (polygons) : spatial extent\n#' @param margin number : buffer of bounding box\n#' @param resolution number : distance between nodes\n#'\n#' @return dataframe of coordinates (x, y)\ngenerate_grid <- memoise::memoise(function(zone, margin, resolution) {\n  \n  zone_bbox <- sf::st_bbox(zone)\n  \n  zone %>%\n    sf::st_make_grid(cellsize = resolution,\n                     offset = c(round_any(zone_bbox[1] - margin, resolution, floor),\n                                round_any(zone_bbox[2] - margin, resolution, floor)),\n                     what = \"centers\") %>%\n    sf::st_sf() %>%\n    sf::st_join(zone, join = st_intersects, left = FALSE) %>%\n    sf::st_coordinates() %>%\n    tibble::as_tibble() %>%\n    dplyr::select(x = X, y = Y)\n})\n\n\n# main function -----------------------------------------------------------\n\n#' Kernel weighted smoothing with arbitrary bounding area\n#'\n#' @param df sf object (points) : features to smooth\n#' @param field expression : weight field in df (unquoted) ; the values must not have NAs\n#' @param bandwidth numeric : kernel bandwidth (output map units)\n#' @param resolution numeric : output grid resolution (output map units)\n#' @param zone sf objet (polygons) : study zone boundary. If null will use df extent\n#' @param out_crs integer : EPSG code projection for output raster (should be an equal-area projection)\n#' @param ... other arguments passed to btb::kernelSmoothing\n#'\n#' @return a raster object\n#' @export\n#' @import btb, raster, fasterize, dplyr, sf, rlang, memoise\nlissage <- function(df, field, bandwidth, resolution, zone = NULL, out_crs = 3035, ...) {\n  \n  field_name <- rlang::as_name(rlang::enquo(field))\n  \n  if (!\"sf\" %in% class(df)\n      | sf::st_geometry_type(df, FALSE) != \"POINT\") {\n    stop(\"« df » should be a point sf object.\")\n  }\n  \n  if (!is.numeric(bandwidth)) stop(\"bandwidth sould be numeric.\")\n  if (!is.numeric(resolution)) stop(\"resolution sould be numeric.\")\n  \n  nb_na <- sum(is.na(dplyr::pull(df, {{field}})))\n  if (nb_na > 0) {\n    warning(paste(\"removing\", nb_na, \"NA\",\n                  paste0(\"value\", ifelse(nb_na > 1, \"s\", \"\")),\n                  \"in «\", field_name, \"»...\"))\n    df <- tidyr::drop_na(df, {{field}}) %>%\n      sf::st_as_sf()\n  }\n  \n  # check projections\n  if (is.na(sf::st_crs(df))) {\n    stop(\"missing projection in sf object « df ».\")\n  }\n  \n  if (sf::st_crs(df)$epsg != out_crs) {\n    message(\"reprojecting data...\")\n    df <- sf::st_transform(df, out_crs)\n  }\n  \n  if (!is.null(zone)) {\n    if (!\"sf\" %in% class(zone)\n        |!sf::st_geometry_type(zone, FALSE) %in% c(\"POLYGON\", \"MULTIPOLYGON\")) {\n      stop(\"« zone » should be a polygon/multiploygon sf object.\")\n    }\n    \n    # check projections\n    if (is.na(sf::st_crs(zone))) {\n      stop(\"missing projection in sf object « zone ».\")\n    }\n    \n    if (sf::st_crs(zone)$epsg != out_crs) {\n      message(\"reprojecting study zone...\")\n      zone <- sf::st_transform(zone, out_crs)\n    }\n    \n    # grid generation\n    if (memoise::has_cache(generate_grid)(zone, bandwidth, resolution)) {\n      message(\"retrieving reference grid from cache...\")\n    } else {\n      message(\"generating reference grid...\")\n    }\n    \n    zone_xy <- generate_grid(zone, bandwidth, resolution)\n    zone_bbox <- sf::st_bbox(zone)\n    \n  } else {\n    message(\"using default reference grid...\")\n    \n    zone_xy <- NULL\n    zone_bbox <- sf::st_bbox(df)\n  }\n  \n  # kernel\n  message(paste0(\"computing kernel on « \", field_name, \" »...\"))\n  kernel <- df %>%\n    bind_cols(., sf::st_coordinates(.) %>% # si pas de données renvoie vecteur non nommé\n                as.data.frame() %>%     # donc on le modifie\n                set_names(c(\"x\", \"y\"))) %>%\n    sf::st_drop_geometry() %>%\n    dplyr::select(x, y, {{ field }}) %>%\n    btb::btb_smooth(sEPSG = out_crs,\n                    iCellSize = resolution,\n                    iBandwidth = bandwidth,\n                    dfCentroids = zone_xy, ...)\n  \n  # rasterization\n  message(\"\\nrasterizing...\")\n  raster::raster(xmn = round_any(zone_bbox[1] - bandwidth, resolution, floor),\n                 ymn = round_any(zone_bbox[2] - bandwidth, resolution, floor),\n                 xmx = round_any(zone_bbox[3] + bandwidth, resolution, ceiling),\n                 ymx = round_any(zone_bbox[4] + bandwidth, resolution, ceiling),\n                 resolution = resolution,\n                 crs = sf::st_crs(out_crs)$input\n  ) %>%\n    fasterize::fasterize(kernel, ., field = field_name)\n}\n\n\n\n\nvoir le code\n# contour de la métropole (pour limiter le lissage à l'intérieur des frontières)\nfr <- read_sf(cnx, query = \"\n  SELECT \n    st_union(st_transform(geom, 3035)) as geom\n  FROM adminexpress.region\n  WHERE insee_reg > '06'\")\n\n# communes (pour donner un nom à nos bassins de production)\ncom <- read_sf(cnx, query = \"\n  SELECT \n    nom,\n    population,\n    st_transform(geom, 3035) as geom\n  FROM adminexpress.commune\n  WHERE insee_reg > '06'\")\n\n# un point par parcelle de maïs avec sa surface qui servira de poids au lissage\nmais <- read_sf(cnx, query = \"\n  SELECT \n    st_transform(st_pointonsurface(geom), 3035) as geom,\n    surf_parc\n  FROM rpg.parcelles\n  WHERE code_cultu = 'MIS'\")\n\n\n\n\nvoir le code\n# lissage à 10 km de \"bande passante\" avec un pixel de 1 km\nmais_liss <- mais %>% \n  lissage(surf_parc, 10000, 1000, zone = fr) %>% \n  rast()\n\nplot(mais_liss, main = \"Densité de culture de maïs grain 2022 (ha/km²)\")\n\n\n\n\n\nvoir le code\nseuil_lissage <- 8 # seuil de densité à prendre en compte (ha/km²)\n\n\nOn peut garder par exemple les densités supérieures à 8 ha/km².\n\n\nvoir le code\nplot(mais_liss > seuil_lissage, main = glue(\"Zones de culture de maïs grain 2022 (> {seuil_lissage} ha/km²)\"))\n\n\n\n\n\nvoir le code\n# vectorisation et conservation des 10 + grandes zones\ncluster_liss <- (mais_liss > seuil_lissage) %>% \n  as.polygons() %>% \n  st_as_sf() %>% \n  filter(layer == 1) %>% \n  st_cast(\"POLYGON\") %>% \n  mutate(surf = st_area(geometry)) %>% \n  slice_max(surf, n = 10) %>% \n  mutate(id = row_number())\n\n# nommage des clusters avec le nom de la plus grosse ville de la zone\nnoms <- cluster_liss %>% \n  st_join(com, left = TRUE) %>% \n  st_drop_geometry() %>% \n  group_by(id) %>% \n  slice_max(population, n = 1, with_ties = FALSE) %>% \n  select(id, nom)\n\n# préparations de points pour l'extraction des températures\npoints <- cluster_liss %>% \n  inner_join(noms) %>% \n  st_point_on_surface() %>% \n  st_transform(\"EPSG:4326\")\n\n\n\n\nvoir le code\ncluster_liss %>% \n  inner_join(noms) %>% \n  st_transform(\"EPSG:4326\") %>% \n  leaflet() %>% \n  addPolygons(popup = ~ nom) %>% \n  addTiles()\n\n\n\n\n\n\n\n\n9 Extraction\n\n\nvoir le code\n# données climato\nera5 <- dir_ls(here::here(rep_era5), recurse = TRUE, glob = \"*.nc\") %>% \n  read_stars() %>% \n  rename(temp_moy_k = 1)\n\n# extraction\ntemp_points <- era5 %>% \n  st_extract(points) %>%\n  as_tibble() %>% \n  mutate(temp_moy_c = temp_moy_k - 273.15,\n         date = as_date(time)) %>% \n  full_join(points, ., by = \"geometry\")\n\n\n\n\n10 Calcul des degrés jour et des dates de récolte\n\n\nvoir le code\n# la date n'est pas un bon indicateur pour suivre précisémment une évolution \n# journalière à cause des années bissextiles \n#   -> on utilisara le day of year (doy)\n# yday(ymd(\"2020-04-01\"))\n# yday(ymd(\"2023-04-01\"))\n\n# base de calcul pour maïs : 6 °C\nbase <- 6 # °C\n\n# besoin total à récolte pour un maïs grain de précocité moyenne : 1700 DJ\nbesoin <- 1700 # DJ\n\nrecolte <- temp_points %>% \n  select(date, nom, temp_moy_c) %>% \n  group_by(nom, annee = year(date)) %>% \n  mutate(dj = case_when(yday(date) < 91 ~ 0,\n                        temp_moy_c > 30 ~ 0,\n                        temp_moy_c < base ~ 0,\n                        TRUE ~ temp_moy_c - base),\n         sdj = cumsum(dj)) %>%\n  filter(sdj > besoin) %>% \n  slice_min(date) %>% \n  ungroup() %>% \n  select(date, annee, nom)\n\n\n\n\n\n\nTableau 1 –  Dates de récolte potentielles\n\n\ndate\nannee\nnom\ngeometry\n\n\n\n\n1979-10-19\n1979\nChâteaudun\nPOINT (1.577058 48.06812)\n\n\n1980-10-28\n1980\nChâteaudun\nPOINT (1.577058 48.06812)\n\n\n1979-12-03\n1979\nConcarneau\nPOINT (-3.908205 48.02116)\n\n\n1980-12-23\n1980\nConcarneau\nPOINT (-3.908205 48.02116)\n\n\n1979-10-21\n1979\nLa Flèche\nPOINT (-0.06041688 47.96617)\n\n\n1980-10-27\n1980\nLa Flèche\nPOINT (-0.06041688 47.96617)\n\n\n1979-09-18\n1979\nLes Sables-d’Olonne\nPOINT (-0.8660986 46.40904)\n\n\n1980-09-24\n1980\nLes Sables-d’Olonne\nPOINT (-0.8660986 46.40904)\n\n\n1979-09-09\n1979\nMarmande\nPOINT (0.2411371 44.43877)\n\n\n1980-09-15\n1980\nMarmande\nPOINT (0.2411371 44.43877)\n\n\n1979-09-13\n1979\nPau\nPOINT (-0.495763 43.49416)\n\n\n1980-09-19\n1980\nPau\nPOINT (-0.495763 43.49416)\n\n\n1979-11-27\n1979\nPontivy\nPOINT (-2.89679 48.01789)\n\n\n1980-12-17\n1980\nPontivy\nPOINT (-2.89679 48.01789)\n\n\n1979-09-17\n1979\nSaintes\nPOINT (-0.7897579 45.70839)\n\n\n1980-09-21\n1980\nSaintes\nPOINT (-0.7897579 45.70839)\n\n\n1979-10-04\n1979\nStrasbourg\nPOINT (7.523206 48.24525)\n\n\n1980-12-24\n1980\nStrasbourg\nPOINT (7.523206 48.24525)\n\n\n1979-09-20\n1979\nVaulx-en-Velin\nPOINT (5.105468 46.32942)\n\n\n1980-10-01\n1980\nVaulx-en-Velin\nPOINT (5.105468 46.32942)\n\n\n\n\n…\nPOINT EMPTY\n\n\n\n\n\n\n\n\n11 Visualisation\n\n\nvoir le code\nrecolte  %>% \n  mutate(doy = yday(date),\n         date_virtuelle = as_date(parse_date_time(glue(\"2020-{str_pad(doy, 3, 'left', '0')}\"), \n                                                  orders = \"yj\"))) %>% \n  ggplot(aes(annee, date_virtuelle, color = nom)) +\n  geom_point() +\n  geom_smooth(method = lm) +\n  scale_y_date(date_breaks = \"months\", date_labels = \"%b\") +\n  labs(title = \"Date de récolte potentielle\",\n       subtitle = \"Maïs grain\",\n       x = \"année\",\n       y = \"jour\",\n       color = \"bassin de production\",\n       caption = glue(\"d'après données agroclimatiques ERA5\n                       pour une précocité moyenne ({besoin} DJ, base {base} °C)\"))\n\n\n\n\n\nFigure 1 –  Évolution de la date de récolte potentielle du maïs grain\n\n\n\n\n\n\n12 Tendance\n\n\nvoir le code\nmod <- recolte %>% \n  mutate(doy = yday(date)) %>% \n  glm(doy ~ annee + nom, data = .)\n\ntbl_regression(mod)\n\n\n\n\n\n\n  \n    \n    \n      Characteristic\n      Beta\n      95% CI1\n      p-value\n    \n  \n  \n    annee\n-0.72\n-0.81, -0.62\n<0.001\n    nom\n\n\n\n        Châteaudun\n—\n—\n\n        Concarneau\n30\n25, 35\n<0.001\n        La Flèche\n1.3\n-4.0, 6.5\n0.6\n        Les Sables-d'Olonne\n-18\n-23, -13\n<0.001\n        Marmande\n-28\n-33, -23\n<0.001\n        Pau\n-23\n-28, -18\n<0.001\n        Pontivy\n26\n20, 31\n<0.001\n        Saintes\n-19\n-24, -14\n<0.001\n        Strasbourg\n-7.9\n-13, -2.7\n0.003\n        Vaulx-en-Velin\n-18\n-24, -13\n<0.001\n  \n  \n  \n    \n      1 CI = Confidence Interval"
  }
]