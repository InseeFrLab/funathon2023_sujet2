[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Funathon 2023 - Sujet 2",
    "section": "",
    "text": "Contexte et description du sujet\nAvec ce sujet, vous allez pouvoir :\n\nUtiliser une base de données PostgreSQL\nTravailler avec des données géographiques\nA compléter"
  },
  {
    "objectID": "app0.html",
    "href": "app0.html",
    "title": "1  Utilisation de PostgreSQL",
    "section": "",
    "text": "A compléter."
  },
  {
    "objectID": "app1.html",
    "href": "app1.html",
    "title": "2  Exploration des données RPG",
    "section": "",
    "text": "A compléter davantage."
  },
  {
    "objectID": "app2.html#données",
    "href": "app2.html#données",
    "title": "3  Cultures et prévisions climatiques",
    "section": "3.1 Données",
    "text": "3.1 Données\n\nLe RPG recense les parcelles déclarées à la PAC par les agriculteurs, leurs informations graphiques et leur culture principale. Ces données sont mises à disposition dans une base de données PostgreSQL.\nLe projet Drias a pour vocation de mettre à disposition des projections climatiques réalisées dans les laboratoires français de modélisation du climat (IPSL, CERFACS, CNRM). En particulier, nous disposons de projections locales du modèle CNRM-CM5 / ALADIN63 / correction ADAMONT. Ces données sont aussi mises à disposition sur PostgreSQL."
  },
  {
    "objectID": "app2.html#visualisations",
    "href": "app2.html#visualisations",
    "title": "3  Cultures et prévisions climatiques",
    "section": "3.2 Visualisations",
    "text": "3.2 Visualisations\n\n\nCode\nlibrary(RPostgres)\nlibrary(dplyr)\nlibrary(aws.s3)\nlibrary(ggplot2)\nlibrary(raster)\nlibrary(sf)\nlibrary(janitor)\nlibrary(knitr)\n\n# pour avoir les noms de dates en français\ninvisible(Sys.setlocale(\"LC_ALL\", \"fr_FR.UTF-8\"))\n\noptions(knitr.kable.NA = \"\")\n\ncnx &lt;- dbConnect(Postgres(),\n                 user = \"projet-funathon\",\n                 password = Sys.getenv(\"PASS_POSTGRESQL\"),\n                 host = \"postgresql-438832\",\n                 dbname = \"defaultdb\",\n                 port = 5432,\n                 check_interrupts = TRUE)\n\n\nOn souhaite tout d’abord visualiser les données DRIAS. On peut passer par les données sauvegardées au format raster qui sont stockées dans l’espace de stockage du SSP Cloud. Ces données correspondent à des prévisions à horizon proche (2021-2050) dans un scénario sans réduction des gaz à effet de serre, la période de référence étant 1976-2005.\n\n\nCode\ndrias_raster &lt;- s3read_using(\n  function(f) readAll(brick(f)),\n  object = \"2023/sujet2/resultats/drias.tif\",\n  bucket = \"projet-funathon\",\n  opts = list(\"region\" = \"\"))\n\ndrias_df &lt;- as.data.frame(drias_raster, xy = TRUE) %&gt;% tidyr::drop_na()\ncolnames(drias_df) &lt;- c(\n  \"x\",\n  \"y\",\n  \"NORRRA\",\n  \"NORSTM6\",\n  \"NORSTM0\",\n  \"NORSDA\",\n  \"NORDATEVEG\",\n  \"NORDATEDG\",\n  \"NORDATEPG\",\n  \"ARRA\",\n  \"ASTM6\",\n  \"ASTM0\",\n  \"ASDA\",\n  \"ADATEVEG\",\n  \"ADATEDG\",\n  \"ADATEPG\",\n  \"ALTI\"\n)\n\ndrias_df %&gt;% head(10) %&gt;% kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nx\ny\nNORRRA\nNORSTM6\nNORSTM0\nNORSDA\nNORDATEVEG\nNORDATEDG\nNORDATEPG\nARRA\nASTM6\nASTM0\nASDA\nADATEVEG\nADATEDG\nADATEPG\nALTI\n\n\n\n\n633293.9\n7102526\n456.2670\n1922.013\n3166.204\n1.970000\n37.00000\n246.0130\n155.0000\n39.48190\n186.3422\n242.3578\n0.1700000\n-6.000000\n-13.02608\n9.934794\n2.000000\n\n\n641293.9\n7102526\n443.9363\n1991.938\n3238.004\n1.703398\n37.00000\n231.1888\n156.9748\n35.79594\n182.8340\n240.3554\n0.1305034\n-6.000000\n-15.96224\n1.113275\n2.000000\n\n\n649293.9\n7102526\n443.9973\n1995.349\n3242.516\n1.867938\n37.00000\n227.0485\n157.9879\n31.54168\n181.4070\n241.3870\n0.3670885\n-6.000000\n-21.92721\n1.987869\n1.012131\n\n\n657293.9\n7102526\n436.6220\n2002.273\n3246.039\n2.067665\n37.00000\n232.9299\n158.0000\n24.67677\n188.7414\n250.9591\n0.4688323\n-6.000000\n-18.04671\n6.941618\n2.524666\n\n\n665293.9\n7102526\n435.9528\n2000.971\n3246.324\n2.058306\n37.00000\n230.7806\n158.4439\n24.02635\n186.6487\n248.8539\n0.4583059\n-6.000000\n-17.55612\n3.791823\n2.349045\n\n\n673293.9\n7102526\n435.9154\n2000.555\n3245.984\n2.050102\n37.00000\n230.5032\n158.4994\n23.95581\n186.3682\n248.5634\n0.4501025\n-6.000000\n-17.50064\n3.503203\n2.498078\n\n\n609293.9\n7094526\n479.2000\n1851.100\n3046.770\n1.700000\n39.00000\n242.0000\n152.0000\n52.62000\n193.7900\n246.7000\n0.0300000\n-8.000000\n-21.00000\n6.000000\n66.000000\n\n\n617293.9\n7094526\n468.7586\n1908.667\n3134.378\n1.729833\n38.00558\n244.9832\n152.9944\n51.20793\n195.0927\n248.4005\n-0.0694416\n-7.005584\n-17.02234\n6.000000\n20.256855\n\n\n625293.9\n7094526\n461.2848\n1925.042\n3168.804\n1.968771\n37.00512\n246.9898\n154.9898\n45.70827\n190.3049\n242.9682\n0.1687707\n-6.005122\n-15.01024\n5.005122\n1.603427\n\n\n633293.9\n7094526\n456.2235\n1921.995\n3166.193\n1.970000\n37.00000\n246.0047\n155.0000\n39.42927\n186.3086\n242.3528\n0.1700000\n-6.000000\n-13.00932\n9.976699\n1.997750\n\n\n\n\n\nLes variables disponibles dans les données DRIAS sont systématiquement calculées sur la période 2021-2050 (préfixe NOR), et en écart avec la période de référence (préfixe A) : - RRA : cumul de précipitations d’avril à octobre (mm) - STM6 : somme de température base 6°C d’avril à octobre (°C) - STM0 : somme de température base 0°C d’octobre (année-1) à juillet (année) (°C) - SDA : nombre de jours d’été d’avril à juin (jour(s)) - DATEVEG : date de reprise de végétation en jour julien (date) - DATEDG : Date de dernière gelée avec 1er juillet comme référence (date) - DATEPG : Date de première gelée avec 1er juillet comme référence (date)\nOn visualise la variable ARRA, qui correspond à l’écart de cumul de précipitations d’avril à octobre en mm.\n\n\nCode\n# Bande ARRA\ndrias_raster_arra &lt;- s3read_using(\n  function(f) readAll(raster(f, band = 8)),\n  object = \"2023/sujet2/resultats/drias.tif\",\n  bucket = \"projet-funathon\",\n  opts = list(\"region\" = \"\"))\n\n# Avec palette custom\npalette &lt;- c(\"#1457ff\", \"#3c9aff\", \"#6dc4ff\", \"#a8e1ff\", \"#dff1fb\", \"#f8e9eb\", \"#fca8ab\", \"#f9575d\", \"#f2060b\", \"#a20102\")\nbreaks &lt;- c(-200, -160, -120, -80, -40, -0, 40, 80, 120, 160, 200)\n\nraster::plot(x = drias_raster_arra,\n             col = rev(palette),\n             breaks = breaks,\n             main = \"Ecart de cumul de précipitations d'avril à octobre (mm) entre 2021-2050 et 1976-2005\")\n\n\n\n\n\nSur la période 2021-2050, les précipitations vont augmenter presque partout, sauf Sud-Ouest de la France (détails…)."
  },
  {
    "objectID": "app2.html#requêtes-postgresql",
    "href": "app2.html#requêtes-postgresql",
    "title": "3  Cultures et prévisions climatiques",
    "section": "3.3 Requêtes PostgreSQL",
    "text": "3.3 Requêtes PostgreSQL\nLes données sont également stockées dans une base PostgreSQL qu’il est possible de requêter. La table drias.previsions contient une grille équivalente aux données raster précédemment utilisées.\n\n\nCode\nquery &lt;- \"\nSELECT *\nFROM drias.previsions\n\"\ndrias_sf &lt;- st_read(cnx, query = query)\n\nggplot() + \n  geom_sf(data = drias_sf, aes(fill = arra), color = NA) +\n  binned_scale(aesthetics = \"fill\", scale_name = \"custom\", \n               palette = ggplot2:::binned_pal(scales::manual_pal(values = rev(palette)[-1])),\n               guide = \"bins\",\n               breaks = breaks)"
  },
  {
    "objectID": "app2.html#appariement-spatial-entre-données-drias-et-rpg",
    "href": "app2.html#appariement-spatial-entre-données-drias-et-rpg",
    "title": "3  Cultures et prévisions climatiques",
    "section": "3.4 Appariement spatial entre données DRIAS et RPG",
    "text": "3.4 Appariement spatial entre données DRIAS et RPG\nOn souhaite effectuer cet appariement pour obtenir par carreau de la grille DRIAS la surface de parcelles pour chaque type de culture.\n\n\nCode\n# On récupère par carreau de la grille DRIAS la surface pour chaque type de culture\nquery &lt;- \"\nSELECT B.point, code_cultu, Sum(surf_parc) AS surface, B.arra\nFROM rpg.parcelles AS A\nJOIN drias.previsions AS B\nON ST_Intersects(A.geom , B.geometry)\nGROUP BY B.point, B.arra, code_cultu\n\"\nres &lt;- dbSendQuery(cnx, query)\narra_df &lt;- dbFetch(res)\n\narra_df %&gt;% head(10) %&gt;% kable()\n\n\n\n\n\npoint\ncode_cultu\nsurface\narra\n\n\n\n\n5343\nCZH\n78.79\n10.30\n\n\n4803\nBTH\n18.06\n23.71\n\n\n3903\nBTA\n25.21\n-36.38\n\n\n3498\nVRG\n10.59\n0.66\n\n\n5078\nVRN\n0.65\n12.48\n\n\n4939\nORH\n186.01\n10.59\n\n\n3624\nTTH\n90.12\n-13.35\n\n\n4636\nFAG\n0.80\n35.12\n\n\n5108\nJ6S\n5.05\n0.70\n\n\n4640\nVRG\n0.31\n23.72\n\n\n\n\n\nOn a récupéré une table avec la surface par type de culture pour chaque carreau de la grille."
  },
  {
    "objectID": "app2.html#calcul-dindicateurs-par-type-de-culture",
    "href": "app2.html#calcul-dindicateurs-par-type-de-culture",
    "title": "3  Cultures et prévisions climatiques",
    "section": "3.5 Calcul d’indicateurs par type de culture",
    "text": "3.5 Calcul d’indicateurs par type de culture\nOn peut maintenant calculer un écart moyen de cumul de précipitation (d’avril à octobre) par unité de surface pour chaque culture, afin identifier celles qui seront impactées par des baisses de précipitations à horizon proche.\n\n\nCode\n# Récupération des libellés des codes culture\nculture_mapping &lt;- s3read_using(\n  FUN = read.csv,\n  sep = \";\",\n  object = \"2023/sujet2/ign/rpg/CULTURE.csv\",\n  bucket = \"projet-funathon\",\n  opts = list(\"region\" = \"\")\n)\n\n# On aggrège au niveau national par code culture et on calcule un écart\n# moyen du cumul par m2\nagg_arra_df &lt;- arra_df %&gt;%\n  group_by(code_cultu) %&gt;%\n  summarise(ecart_volume_precip = sum(surface * arra), surface = sum(surface)) %&gt;%\n  mutate(ecart_cumul_moyen = ecart_volume_precip / surface)\n\n# Récupération des 10 cultures avec une forte perte de précipitation\nagg_arra_df %&gt;%\n  dplyr::left_join(culture_mapping, by = c(\"code_cultu\" = \"Code\")) %&gt;%\n  arrange(ecart_cumul_moyen) %&gt;%\n  head(10) %&gt;%\n  kable()\n\n\n\n\n\n\n\n\n\n\n\n\ncode_cultu\necart_volume_precip\nsurface\necart_cumul_moyen\nLibellé\n\n\n\n\nPVP\n-13726.4694\n346.56\n-39.607772\nPoivron / Piment\n\n\nMID\n-310201.4660\n26283.67\n-11.802061\nMaïs doux\n\n\nSGE\n-24903.3477\n3327.82\n-7.483382\nSauge\n\n\nARA\n-541.0369\n76.50\n-7.072378\nArachide\n\n\nLAV\n105054.4076\n35387.95\n2.968649\nLavande / Lavandin\n\n\nSPH\n6608775.8514\n2041360.68\n3.237437\nSurface pastorale - herbe prédominante et ressources fourragères ligneuses présentes\n\n\nVAL\n107.8679\n31.53\n3.421120\nValériane\n\n\nPAQ\n158.4835\n26.45\n5.991815\nPâquerette\n\n\nCRN\n70.0155\n10.77\n6.500975\nCornille\n\n\nNVH\n180.2147\n25.00\n7.208588\nNavette d’hiver\n\n\n\n\n\nLe maïs doux est une culture qui sera touchée par les baisses de précipitations à horizon proche. Où sont situées les parcelles de maïs doux ?\n\n\nCode\n# Frontières régionales de métropole\nregion_sf &lt;- st_read(\n  cnx, query = \"SELECT * FROM adminexpress.region\"\n)\nregion_sf &lt;- region_sf %&gt;% st_transform(\n  \"EPSG:2154\"\n)\nregion_sf &lt;- region_sf %&gt;%\n  dplyr::filter(!(insee_reg %in% c(\"03\", \"04\", \"06\", \"01\", \"02\", \"01_SBSM\")))\n\n# Parcelles de maïs doux\nquery_mid &lt;- \"\nSELECT id_parcel, geom\nFROM rpg.parcelles\nWHERE code_cultu = 'MID'\n\"\ncultures_mid &lt;- st_read(cnx, query = query_mid)\nggplot() + \n  geom_sf(data = region_sf) +\n  geom_sf(data = st_buffer(cultures_mid, 5000), fill = \"#fca8ab\", color = NA)\n\n\n\n\n\nOn observe en effet beaucoup de parcelles dans le Sud-Ouest où des baisses de précipitations sont attendues à horizon proche."
  },
  {
    "objectID": "physio_era5.html",
    "href": "physio_era5.html",
    "title": "4  Évolution de la date théorique de récolte",
    "section": "",
    "text": "Les organismes, dont les plantes, ont besoin d’une certaine quantité de chaleur pour se développer. La notion de degrés jours a été introduite par les biologistes pour quantifier ce besoin physiologique. Il s’exprime par la somme des différences entre la température moyenne journalière et une température de base1.1 Degré jour de croissance. Wikipedia\nPeut-on voir comment a évolué la date de récolte théorique du maïs au cours des 40 dernières années ?\n\n5 Données\n\nLe RPG recense les parcelles déclarées à la PAC (Politique agricole commune) par les agricuteurs : données graphiques et leur culture principale.\nLes données 2021 (environ 10 millions de parcelles) sont disponibles dans une base PostgreSQL/PostGIS.\nERA5 agrometeorological indicators est un jeu de données issu d’un projet de réanalyse météorologique qui vise à uniformiser et corriger les données historiques (ERA5). Il fournit des paramètres agro-météorologiques de surface quotidiens sur les quarante dernières années à une résolution spatiale de 0,1 ° (soit environ 8×11 km en France).\nLes données de température moyenne journalière 1979-2022 (87 Go à l’origine) ont été préchargées sur Minio et limitées à l’emprise de la métropole, représentant au final 16 000 fichiers de 76 ko = 1.1 Go).\nElles sont au format NetCDF. Un package R existe pour importer et requêter ce jeu de données particulier : {ag5Tools}. Les données peuvent aussi être traitées avec les packages de manipulation de rasters tels que {terra} (ou {raster}) et {stars}.\n\n\n\n6 Proposition\nEstimer les tendances de la date potentielle de récolte du maïs grain dans les différents bassins de productions français depuis 1980.\n\n\n7 Préparation\nRestaurer les packages à utiliser : renv::restore().\nSi ce n’est pas déjà fait, il faut avoir préalablement copié les données depuis le stockage MinIO :\n$ mc cp -r s3/projet-funathon/2023/sujet2/era5/ funathon2023_sujet2/data/era5/\nPour se connecter à la base PostgreSQL, il faudra avoir défini votre mot de passe comme variable d’environnement par exemple en ajoutant PASS_POSTGRESQL=xxxx dans le fichier ~/.Renviron : file.edit(\"~/.Renviron\") et relancer la session (ctrl+maj+F10).\n\n\nCode\nlibrary(stars) # manipulation de rasters\nlibrary(terra) # manipulation de rasters\nlibrary(tidyverse) # manipulation des données\nlibrary(glue)      # interpolation de chaine de caractères\nlibrary(fs)        # gestion du système de fichier\nlibrary(gtsummary) # tableaux de modèles stat\nlibrary(RPostgres) # connxion PostgreSQL\nlibrary(sf)        # manipulation de données spatiales vecteur\nlibrary(leaflet)   # carto web\nlibrary(knitr)     # génération du document\nlibrary(ggrepel)   # étiquettage graphiques\n\n\n# localisation des données dans le stockage \"local\"\nrep_era5 &lt;- \"data/era5\"\n\n# pour avoir les noms de dates en français\ninvisible(Sys.setlocale(\"LC_ALL\", \"fr_FR.UTF-8\"))\n\noptions(knitr.kable.NA = \"\")\n\ncnx &lt;- dbConnect(Postgres(),\n                 user = \"projet-funathon\",\n                 password = Sys.getenv(\"PASS_POSTGRESQL\"),\n                 host = \"postgresql-438832\",\n                 dbname = \"defaultdb\",\n                 port = 5432,\n                 check_interrupts = TRUE)\n\n\n\n\n8 Définition des bassins de production du maïs grain\nLe maïs grain (code culture : MIS) représente environ 6 % des surfaces déclarées à la PAC en France en 2021.\nOn peut, par exemple, extraire les principales zones où la densité de culture du maïs grain est la plus forte. Cela peut se faire par commune, par clustering ou avec un lissage.\nOn présente ici un exemple avec un lissage filtré.\n\n\nCode\n# Lissage\n#\n# michael.delorme - 2021-08-26\n\n# utils -------------------------------------------------------------------\n\n#' rounding\n#' from plyr\n#'\n#' @param x\n#' @param accuracy\n#' @param f\n#'\n#' @return\nround_any &lt;- function(x, accuracy, f = round) {\n  \n  f(x / accuracy) * accuracy\n}\n\n#' Generate a grid of coordinates from a spatial layer\n#'\n#' Memoised to get a faster result when used multiple times on the same extent\n#'\n#' @param zone sf object (polygons) : spatial extent\n#' @param margin number : buffer of bounding box\n#' @param resolution number : distance between nodes\n#'\n#' @return dataframe of coordinates (x, y)\ngenerate_grid &lt;- memoise::memoise(function(zone, margin, resolution) {\n  \n  zone_bbox &lt;- sf::st_bbox(zone)\n  \n  zone %&gt;%\n    sf::st_make_grid(cellsize = resolution,\n                     offset = c(round_any(zone_bbox[1] - margin, resolution, floor),\n                                round_any(zone_bbox[2] - margin, resolution, floor)),\n                     what = \"centers\") %&gt;%\n    sf::st_sf() %&gt;%\n    sf::st_join(zone, join = st_intersects, left = FALSE) %&gt;%\n    sf::st_coordinates() %&gt;%\n    tibble::as_tibble() %&gt;%\n    dplyr::select(x = X, y = Y)\n})\n\n\n# main function -----------------------------------------------------------\n\n#' Kernel weighted smoothing with arbitrary bounding area\n#'\n#' @param df sf object (points) : features to smooth\n#' @param field expression : weight field in df (unquoted) ; the values must not have NAs\n#' @param bandwidth numeric : kernel bandwidth (output map units)\n#' @param resolution numeric : output grid resolution (output map units)\n#' @param zone sf objet (polygons) : study zone boundary. If null will use df extent\n#' @param out_crs integer : EPSG code projection for output raster (should be an equal-area projection)\n#' @param ... other arguments passed to btb::kernelSmoothing\n#'\n#' @return a raster object\n#' @export\n#' @import btb, raster, fasterize, dplyr, sf, rlang, memoise\nlissage &lt;- function(df, field, bandwidth, resolution, zone = NULL, out_crs = 3035, ...) {\n  \n  field_name &lt;- rlang::as_name(rlang::enquo(field))\n  \n  if (!\"sf\" %in% class(df)\n      | sf::st_geometry_type(df, FALSE) != \"POINT\") {\n    stop(\"« df » should be a point sf object.\")\n  }\n  \n  if (!is.numeric(bandwidth)) stop(\"bandwidth sould be numeric.\")\n  if (!is.numeric(resolution)) stop(\"resolution sould be numeric.\")\n  \n  nb_na &lt;- sum(is.na(dplyr::pull(df, {{field}})))\n  if (nb_na &gt; 0) {\n    warning(paste(\"removing\", nb_na, \"NA\",\n                  paste0(\"value\", ifelse(nb_na &gt; 1, \"s\", \"\")),\n                  \"in «\", field_name, \"»...\"))\n    df &lt;- tidyr::drop_na(df, {{field}}) %&gt;%\n      sf::st_as_sf()\n  }\n  \n  # check projections\n  if (is.na(sf::st_crs(df))) {\n    stop(\"missing projection in sf object « df ».\")\n  }\n  \n  if (sf::st_crs(df)$epsg != out_crs) {\n    message(\"reprojecting data...\")\n    df &lt;- sf::st_transform(df, out_crs)\n  }\n  \n  if (!is.null(zone)) {\n    if (!\"sf\" %in% class(zone)\n        |!sf::st_geometry_type(zone, FALSE) %in% c(\"POLYGON\", \"MULTIPOLYGON\")) {\n      stop(\"« zone » should be a polygon/multiploygon sf object.\")\n    }\n    \n    # check projections\n    if (is.na(sf::st_crs(zone))) {\n      stop(\"missing projection in sf object « zone ».\")\n    }\n    \n    if (sf::st_crs(zone)$epsg != out_crs) {\n      message(\"reprojecting study zone...\")\n      zone &lt;- sf::st_transform(zone, out_crs)\n    }\n    \n    # grid generation\n    if (memoise::has_cache(generate_grid)(zone, bandwidth, resolution)) {\n      message(\"retrieving reference grid from cache...\")\n    } else {\n      message(\"generating reference grid...\")\n    }\n    \n    zone_xy &lt;- generate_grid(zone, bandwidth, resolution)\n    zone_bbox &lt;- sf::st_bbox(zone)\n    \n  } else {\n    message(\"using default reference grid...\")\n    \n    zone_xy &lt;- NULL\n    zone_bbox &lt;- sf::st_bbox(df)\n  }\n  \n  # kernel\n  message(paste0(\"computing kernel on « \", field_name, \" »...\"))\n  kernel &lt;- df %&gt;%\n    bind_cols(., sf::st_coordinates(.) %&gt;% # si pas de données renvoie vecteur non nommé\n                as.data.frame() %&gt;%     # donc on le modifie\n                set_names(c(\"x\", \"y\"))) %&gt;%\n    sf::st_drop_geometry() %&gt;%\n    dplyr::select(x, y, {{ field }}) %&gt;%\n    btb::btb_smooth(sEPSG = out_crs,\n                    iCellSize = resolution,\n                    iBandwidth = bandwidth,\n                    dfCentroids = zone_xy, ...)\n  \n  # rasterization\n  message(\"\\nrasterizing...\")\n  raster::raster(xmn = round_any(zone_bbox[1] - bandwidth, resolution, floor),\n                 ymn = round_any(zone_bbox[2] - bandwidth, resolution, floor),\n                 xmx = round_any(zone_bbox[3] + bandwidth, resolution, ceiling),\n                 ymx = round_any(zone_bbox[4] + bandwidth, resolution, ceiling),\n                 resolution = resolution,\n                 crs = sf::st_crs(out_crs)$input\n  ) %&gt;%\n    fasterize::fasterize(kernel, ., field = field_name)\n}\n\n\n\n\nCode\n# Utilisation d'une projection dite \"équivalente\" (conservant les surfaces), la LAEA EPSG:3035.\n\n# contour de la métropole (pour limiter le lissage à l'intérieur des frontières)\nfr &lt;- read_sf(cnx, query = \"\n  SELECT \n    st_union(st_transform(geom, 3035)) as geom\n  FROM adminexpress.region\n  WHERE insee_reg &gt; '06'\")\n\n# communes (pour donner un nom à nos bassins de production)\ncom &lt;- read_sf(cnx, query = \"\n  SELECT \n    nom,\n    population,\n    st_transform(geom, 3035) as geom\n  FROM adminexpress.commune\n  WHERE insee_reg &gt; '06'\")\n\n# un point par parcelle de maïs avec sa surface qui servira de poids au lissage\nmais &lt;- read_sf(cnx, query = \"\n  SELECT \n    st_transform(st_pointonsurface(geom), 3035) as geom,\n    surf_parc\n  FROM rpg.parcelles\n  WHERE code_cultu = 'MIS'\")\n\n\n\n\nCode\n# lissage à 10 km de \"bande passante\" avec un pixel de 1 km\n# NB : le lissage ne peut pas être mis en cache car les objets {terra} ne sont pas cachables.\nmais_liss &lt;- mais %&gt;% \n  lissage(surf_parc, 10000, 1000, zone = fr) %&gt;% \n  rast()\n\n\n\n\nCode\nplot(mais_liss, main = \"Densité de culture de maïs grain 2021 (ha/km²)\")\n\n\n\n\n\nFigure 1 –  Lissage\n\n\n\n\n\n\nCode\nseuil_lissage &lt;- 8  # seuil de densité à prendre en compte (ha/km²)\nnb_bassins    &lt;- 10 # combien de bassins on conserve\n\n\nOn peut garder par exemple les densités supérieures à 8 ha/km² et on conservera les 10 plus grandes zones.\n\n\nCode\nplot(mais_liss &gt; seuil_lissage, main = glue(\"Zones de culture de maïs grain 2021 (&gt; {seuil_lissage} ha/km²)\"))\n\n\n\n\n\nFigure 2 –  Lissage filtré\n\n\n\n\n\n\nCode\n# vectorisation et conservation des nb_bassins + grandes zones\ncluster_liss &lt;- (mais_liss &gt; seuil_lissage) %&gt;% \n  as.polygons() %&gt;% \n  st_as_sf() %&gt;% \n  filter(layer == 1) %&gt;% \n  st_cast(\"POLYGON\") %&gt;% \n  mutate(surf = st_area(geometry)) %&gt;% \n  slice_max(surf, n = nb_bassins) %&gt;% \n  mutate(id = row_number())\n\n# nommage des clusters avec le nom de la plus grosse ville de la zone\nnoms &lt;- cluster_liss %&gt;% \n  st_join(com, left = TRUE) %&gt;% \n  st_drop_geometry() %&gt;% \n  group_by(id) %&gt;% \n  slice_max(population, n = 1, with_ties = FALSE) %&gt;% \n  select(id, nom)\n\n# préparations de points pour l'extraction des températures\npoints &lt;- cluster_liss %&gt;% \n  inner_join(noms) %&gt;% \n  st_point_on_surface() %&gt;% \n  st_transform(\"EPSG:4326\")\n\n\n\n\nCode\ncluster_liss %&gt;% \n  inner_join(noms) %&gt;% \n  st_transform(\"EPSG:4326\") %&gt;% \n  leaflet() %&gt;% \n  addPolygons(popup = ~ glue(\"{id}. {nom}\")) %&gt;% \n  addTiles()\n\n\n\n\n\nFigure 3 –  Les 10 bassins de production retenus\n\n\n\n\n\n9 Extraction des températures à chaque point\nPour chaque bassin de production, on peut prendre un “centroïde” et récupérer les données de température journalières pour ces points.\n\n\nCode\n# données climato\nera5 &lt;- dir_ls(here::here(rep_era5), recurse = TRUE, glob = \"*.nc\") %&gt;% \n  read_stars() %&gt;% \n  rename(temp_moy_k = 1)\n\n# extraction\ntemp_points &lt;- era5 %&gt;% \n  st_extract(points) %&gt;%\n  as_tibble() %&gt;% \n  mutate(temp_moy_c = temp_moy_k - 273.15,\n         date = as_date(time)) %&gt;% \n  full_join(points, ., by = \"geometry\")\n\n\n\n\n10 Calcul des degrés jour et des dates de récolte\n\\[DJ_{n} = \\sum_{j=1}^{n}{\\frac{T_{max, j} - T_{min, j}}{2} - T_{base}}\\]\nLe maïs a une température de base de 6 °C et il lui faut 1500 DJ (variable selon la précocité de la variété) pour être récolté pour l’ensilage2 destiné à nourrir le bétail, ou 1700 DJ pour le maïs grain. Les températures supérieures à 30 °C stoppent le développement végétatif. Le semis se fait début avril3.2 Spotifarm3 Céré’Obs. FranceAgrimer\nOn considère que la température moyenne journalière ERA5 correspond à \\(\\frac{T_{max} - T_{min}}{2}\\).\n\n\nCode\n# la date n'est pas un bon indicateur pour suivre précisémment une évolution \n# journalière à cause des années bissextiles \n#   -&gt; on utilisara le day of year (doy)\n# yday(ymd(\"2020-04-01\"))\n# yday(ymd(\"2023-04-01\"))\n\n# base de calcul pour maïs : 6 °C\nbase &lt;- 6 # °C\n\n# besoin total à récolte pour un maïs grain de précocité moyenne : 1700 DJ\nbesoin &lt;- 1700 # DJ\n\nrecolte &lt;- temp_points %&gt;% \n  select(date, nom, temp_moy_c) %&gt;% \n  group_by(nom, annee = year(date)) %&gt;% \n  mutate(dj = case_when(yday(date) &lt; 91 ~ 0,\n                        temp_moy_c &gt;= 30 ~ 0,\n                        temp_moy_c &lt; base ~ 0,\n                        TRUE ~ temp_moy_c - base),\n         sdj = cumsum(dj)) %&gt;%\n  filter(sdj &gt; besoin) %&gt;% \n  slice_min(date) %&gt;% \n  ungroup() %&gt;% \n  select(date, annee, nom)\n\n\n\n\n\n\nTableau 1 –  Dates de récolte potentielles\n\n\ndate\nannee\nnom\n\n\n\n\n1979-10-19\n1979\nChâteaudun\n\n\n1980-10-28\n1980\nChâteaudun\n\n\n1979-12-03\n1979\nConcarneau\n\n\n1980-12-23\n1980\nConcarneau\n\n\n1979-10-21\n1979\nLa Flèche\n\n\n1980-10-27\n1980\nLa Flèche\n\n\n1979-09-18\n1979\nLes Sables-d’Olonne\n\n\n1980-09-24\n1980\nLes Sables-d’Olonne\n\n\n1979-09-09\n1979\nMarmande\n\n\n1980-09-15\n1980\nMarmande\n\n\n1979-09-13\n1979\nPau\n\n\n1980-09-19\n1980\nPau\n\n\n1979-11-27\n1979\nPontivy\n\n\n1980-12-17\n1980\nPontivy\n\n\n1979-09-17\n1979\nSaintes\n\n\n1980-09-21\n1980\nSaintes\n\n\n1979-10-04\n1979\nStrasbourg\n\n\n1980-12-24\n1980\nStrasbourg\n\n\n1979-09-20\n1979\nVaulx-en-Velin\n\n\n1980-10-01\n1980\nVaulx-en-Velin\n\n\n\n\netc.\n\n\n\n\n\n\n\n\nCode\nmod &lt;- recolte %&gt;% \n  mutate(doy = yday(date)) %&gt;% \n  glm(doy ~ annee + nom, data = .)\n\n# préparation des étiquettes pour la visualisation\netiquettes &lt;- tibble(nom = unique(recolte$nom),\n                     annee = max(recolte$annee) + 1) %&gt;% \n  bind_cols(doy = predict(mod, newdata = .)) %&gt;% \n  mutate(date_virtuelle = as_date(parse_date_time(glue(\"2020-{str_pad(round(doy, 0), 3, 'left', '0')}\"), \n                                                  orders = \"yj\")))\n\n\n\n\n11 Visualisation\n\n\nCode\nrecolte  %&gt;% \n  mutate(doy = yday(date),\n         date_virtuelle = as_date(parse_date_time(glue(\"2020-{str_pad(doy, 3, 'left', '0')}\"), \n                                                  orders = \"yj\"))) %&gt;% \n  ggplot(aes(annee, date_virtuelle, color = nom)) +\n  geom_point() +\n  geom_smooth(method = glm) +\n  geom_text_repel(data = etiquettes, aes(label = str_wrap(nom, 10, whitespace_only = FALSE)),\n                  nudge_x = 1, size = 3, direction = \"y\", lineheight = 0.6) +\n  scale_y_date(date_breaks = \"months\", date_labels = \"%b\") +\n  coord_cartesian(ylim = as.Date(c(NA, \"2020-11-08\"))) +\n  labs(title = \"Date de récolte potentielle\",\n       subtitle = \"Maïs grain\",\n       x = \"année\",\n       y = \"jour\",\n       color = \"bassin de production\",\n       caption = glue(\"d'après données agroclimatiques ERA5\n                       pour une précocité moyenne ({besoin} DJ, base {base} °C)\")) +\n  theme(legend.position = \"none\",\n        plot.caption = element_text(size = 6))\n\n\n\n\n\nFigure 4 –  Évolution de la date de récolte potentielle du maïs grain\n\n\n\n\n\n\n12 Tendance\n\n\nCode\ntheme_gtsummary_language(\"fr\")\ntbl_regression(mod)\n\n\n\n\n\n\nTableau 2 –   Évolution de la date de récolte : environ -0.7 jour par an \n  \n    \n    \n      Caractéristique\n      Beta\n      95% IC1\n      p-valeur\n    \n  \n  \n    annee\n-0.72\n-0.81, -0.62\n&lt;0.001\n    nom\n\n\n\n        Châteaudun\n—\n—\n\n        Concarneau\n30\n25, 35\n&lt;0.001\n        La Flèche\n1.3\n-4.0, 6.5\n0.6\n        Les Sables-d'Olonne\n-18\n-23, -13\n&lt;0.001\n        Marmande\n-28\n-33, -23\n&lt;0.001\n        Pau\n-23\n-28, -18\n&lt;0.001\n        Pontivy\n26\n20, 31\n&lt;0.001\n        Saintes\n-19\n-24, -14\n&lt;0.001\n        Strasbourg\n-7.9\n-13, -2.7\n0.003\n        Vaulx-en-Velin\n-18\n-24, -13\n&lt;0.001\n  \n  \n  \n    \n      1 IC = intervalle de confiance"
  }
]